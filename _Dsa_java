ğŸ“˜ PART 1: Time & Space Complexity (Detailed Answers)
1ï¸âƒ£ What is Time Complexity?

Time Complexity batata hai ki input size badhne par program ka execution time kaise grow karta hai.

ğŸ‘‰ Ye actual time nahi, operations count ka idea deta hai.

Example
for(int i = 0; i < n; i++) {
    System.out.println(i);
}


Loop n times chala

Time Complexity = O(n)

2ï¸âƒ£ What is Space Complexity?

Space Complexity batata hai ki program kitni extra memory use karta hai.

Includes:

Variables

Arrays

Recursion stack

Example
int[] arr = new int[n];


Extra space = n

Space Complexity = O(n)

3ï¸âƒ£ What is Big-O Notation?

Big-O worst-case performance represent karta hai.

ğŸ‘‰ Matlab maximum time jo algorithm le sakta hai.

Notation	Meaning
O(1)	Constant
O(log n)	Logarithmic
O(n)	Linear
O(n log n)	Efficient sorting
O(nÂ²)	Nested loops
4ï¸âƒ£ Difference: Best, Worst & Average Case
Case	Meaning
Best Case	Minimum time
Average Case	Normal expected time
Worst Case	Maximum time (Big-O)

ğŸ‘‰ Interviews me mostly Worst Case (Big-O) pucha jata hai.

5ï¸âƒ£ Time Complexity of Nested Loop
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        // statement
    }
}


Outer loop â†’ n

Inner loop â†’ n

Total = n Ã— n = O(nÂ²)

6ï¸âƒ£ Time Complexity of Recursion

Example: Factorial

int fact(int n){
    if(n==0) return 1;
    return n * fact(n-1);
}


Function calls = n

Time = O(n)

Space = O(n) (recursion stack)

7ï¸âƒ£ What is Auxiliary Space?

Auxiliary space = extra space used by algorithm, input ko chhod ke.

Example:

Recursion stack

Temporary arrays

8ï¸âƒ£ Difference between Time & Space Complexity
Time	Space
Speed	Memory
Execution time	RAM usage
CPU dependent	Memory dependent
9ï¸âƒ£ Why is O(n log n) better than O(nÂ²)?

For large input:

n = 1000

nÂ² = 1,000,000

n log n â‰ˆ 10,000

ğŸ‘‰ Isliye Merge Sort / Quick Sort better hote hain

ğŸ”¥ PART 2: Arrays (Detailed Answers)
10ï¸âƒ£ What is an Array?

Array is a collection of same type elements stored in continuous memory.

int[] arr = {1,2,3,4};

Characteristics

Fixed size

Fast access (index-based)

Insertion/deletion costly

11ï¸âƒ£ Find Maximum & Minimum in Array
int max = arr[0], min = arr[0];

for(int i=1;i<arr.length;i++){
    if(arr[i] > max) max = arr[i];
    if(arr[i] < min) min = arr[i];
}


Time: O(n)

Space: O(1)

12ï¸âƒ£ Reverse an Array
int l = 0, r = arr.length-1;
while(l < r){
    int temp = arr[l];
    arr[l] = arr[r];
    arr[r] = temp;
    l++;
    r--;
}


Time: O(n)

Space: O(1)

13ï¸âƒ£ Find Second Largest Element
int first = Integer.MIN_VALUE;
int second = Integer.MIN_VALUE;

for(int x : arr){
    if(x > first){
        second = first;
        first = x;
    } else if(x > second && x != first){
        second = x;
    }
}

14ï¸âƒ£ Kadaneâ€™s Algorithm (Maximum Subarray Sum)
int maxSum = arr[0];
int currSum = arr[0];

for(int i=1;i<arr.length;i++){
    currSum = Math.max(arr[i], currSum + arr[i]);
    maxSum = Math.max(maxSum, currSum);
}


Time: O(n)

Space: O(1)

15ï¸âƒ£ Two Sum Problem
HashMap<Integer,Integer> map = new HashMap<>();

for(int i=0;i<arr.length;i++){
    int need = target - arr[i];
    if(map.containsKey(need)){
        return new int[]{map.get(need), i};
    }
    map.put(arr[i], i);
}


Time: O(n)

Space: O(n)
ğŸ“˜ PART 3: Linked List + Stack + Queue (Detailed)
ğŸ”— LINKED LIST
What is Linked List?

A Linked List is a linear data structure where elements (nodes) are stored non-contiguously and connected using references (pointers).

Types

Singly Linked List

Doubly Linked List

Circular Linked List

Node Structure (Java)
class Node {
    int data;
    Node next;
    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

Reverse a Linked List
Node prev = null;
Node curr = head;

while(curr != null){
    Node next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
}
head = prev;


â± Time: O(n)
ğŸ“¦ Space: O(1)

Detect Loop (Floyd Cycle Detection)
Node slow = head, fast = head;

while(fast != null && fast.next != null){
    slow = slow.next;
    fast = fast.next.next;
    if(slow == fast) return true;
}
return false;


â± O(n) | ğŸ“¦ O(1)

Find Middle of Linked List
Node slow = head, fast = head;
while(fast != null && fast.next != null){
    slow = slow.next;
    fast = fast.next.next;
}
return slow;

ğŸ“š STACK
What is Stack?

LIFO (Last In First Out)

Operations:

push

pop

peek

Stack using Array
class Stack {
    int top = -1;
    int[] arr = new int[100];

    void push(int x){
        arr[++top] = x;
    }
    int pop(){
        return arr[top--];
    }
}

Valid Parentheses
Stack<Character> st = new Stack<>();

for(char c : s.toCharArray()){
    if(c=='(') st.push(c);
    else {
        if(st.isEmpty()) return false;
        st.pop();
    }
}
return st.isEmpty();

ğŸš¶ QUEUE
What is Queue?

FIFO (First In First Out)

Queue using Array
int front = 0, rear = 0;
int[] q = new int[100];

void enqueue(int x){
    q[rear++] = x;
}

int dequeue(){
    return q[front++];
}

ğŸ“˜ PART 4: Hashing + Trees + BST
ğŸ”‘ HASHING
What is Hashing?

Technique to map keys to values using a hash function.

HashMap Internal Working (Java)

Uses Array + Linked List

From Java 8 â†’ Tree (Red-Black Tree) when collisions > 8

Two Sum using HashMap
HashMap<Integer,Integer> map = new HashMap<>();

for(int i=0;i<arr.length;i++){
    int need = target - arr[i];
    if(map.containsKey(need))
        return new int[]{map.get(need), i};
    map.put(arr[i], i);
}


â± O(n) | ğŸ“¦ O(n)

ğŸŒ³ TREES
Binary Tree

Each node has max 2 children

Tree Traversals
Inorder (LNR)
void inorder(Node root){
    if(root==null) return;
    inorder(root.left);
    System.out.print(root.data+" ");
    inorder(root.right);
}

Preorder (NLR)
Postorder (LRN)
Height of Binary Tree
int height(Node root){
    if(root==null) return 0;
    return 1 + Math.max(height(root.left), height(root.right));
}

ğŸŒ² BST (Binary Search Tree)

Property:

Left < Root

Right > Root

Check if BST
boolean isBST(Node root, int min, int max){
    if(root==null) return true;
    if(root.data <= min || root.data >= max) return false;
    return isBST(root.left, min, root.data) &&
           isBST(root.right, root.data, max);
}

ğŸ“˜ PART 5: Graph + Sorting + Searching
ğŸŒ GRAPH
BFS (Queue)
Queue<Integer> q = new LinkedList<>();
boolean[] visited = new boolean[V];

q.add(0);
visited[0] = true;

while(!q.isEmpty()){
    int node = q.poll();
    for(int n : adj[node]){
        if(!visited[n]){
            visited[n] = true;
            q.add(n);
        }
    }
}

DFS (Recursion)
void dfs(int node, boolean[] visited){
    visited[node] = true;
    for(int n : adj[node]){
        if(!visited[n])
            dfs(n, visited);
    }
}

ğŸ” SEARCHING
Binary Search
int l=0, r=n-1;
while(l<=r){
    int mid = (l+r)/2;
    if(arr[mid]==x) return mid;
    else if(arr[mid]<x) l=mid+1;
    else r=mid-1;
}


â± O(log n)

ğŸ”ƒ SORTING
Bubble Sort
for(int i=0;i<n;i++)
    for(int j=0;j<n-i-1;j++)
        if(arr[j]>arr[j+1])
            swap(arr,j,j+1);


â± O(nÂ²)

Merge Sort
void mergeSort(int[] arr){
    if(arr.length<2) return;
    // divide + merge
}


â± O(n log n)

ğŸ“˜ PART 6: DP + Greedy + Recursion
ğŸ” RECURSION
Factorial
int fact(int n){
    if(n==0) return 1;
    return n * fact(n-1);
}

ğŸ’° GREEDY
Activity Selection

Sort by finishing time

Pick earliest ending activity

â± O(n log n)

ğŸ§  DYNAMIC PROGRAMMING
Fibonacci (DP)
int[] dp = new int[n+1];
dp[0]=0; dp[1]=1;

for(int i=2;i<=n;i++)
    dp[i]=dp[i-1]+dp[i-2];

0/1 Knapsack
for(int i=1;i<=n;i++){
    for(int w=1;w<=W;w++){
        if(wt[i-1]<=w)
            dp[i][w]=Math.max(
              val[i-1]+dp[i-1][w-wt[i-1]],
              dp[i-1][w]);
        else
            dp[i][w]=dp[i-1][w];
    }
}
